<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="ZJ" />


<title>Custom One-Stage Group-by functions</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Custom One-Stage Group-by functions</h1>
<h4 class="author">ZJ</h4>



<div id="custom-one-stage-group-by" class="section level1">
<h1>Custom one-stage group-by</h1>
<div id="at-a-glance" class="section level2">
<h2>At a glance</h2>
<p><code>{disk.frame}</code> allows the user to enable create custom one-stage group-by functions. To make a function <code>fn</code> one stage. One needs to define two functions</p>
<ol style="list-style-type: decimal">
<li><code>fn_df.chunk_agg.disk.frame</code> which applies itself to each chunk</li>
<li><code>fn_df.collected_agg.disk.frame</code> which accepts a <code>list</code> of returns from <code>fn_df.chunk_agg.disk.frame</code> and finalize the computation</li>
</ol>
<p>For example, to make <code>mean</code> a one-stage group-by function, <code>{disk.frame}</code> has defined <code>mean_df.chunk_agg.disk.frame</code> and <code>mean_df.collected_agg.disk.frame</code>, which we will illustrate with examples below.</p>
<p>But first, we shall explain some theory behind <code>{disk.frame}</code> to help you better understand “why does <code>{disk.frame}</code> do it like that?”.</p>
</div>
<div id="how-does-disk.frame-work" class="section level2">
<h2>How does <code>{disk.frame}</code> work</h2>
<p>One may ask, how come only a few functions are supported for one-stage group-by? And why are some functions like <code>median</code> only produce estimates instead of producing the exact figure? To answer these question, we need to have an understanding of how <code>{disk.frame}</code> works.</p>
<p>A <code>disk.frame</code> is organized as chunks stored on disk. Each chunk is a file stored in <a href="https://www.fstpackage.org/">fst format</a>. The <a href="https://CRAN.R-project.org/package=future"><code>{future}</code> package</a> is used to apply the same function to each chunk, each of these operations are carried out in a separate R session. These R sessions cannot communicate with each other during the execution of the operations.</p>
<p>Once the operations have been performed on all chunks, the results will be bought back to the session from which the operations were called. This is the only point of inter-process communication.</p>
<p>To summarize, the two phases of a <code>df %&gt;% some_fn %&gt;% collect</code> operation is</p>
<ol style="list-style-type: decimal">
<li>The <code>some_fn</code> is applied to each chunk, and the result is assumed to be a data.frame</li>
<li><code>collect</code> then row-binds (<code>rbind</code>/<code>bind_rows</code>/<code>rbindlist</code>) the results together to form a data.frame in the main session</li>
</ol>
</div>
<div id="how-group-by-works" class="section level2">
<h2>How group-by works</h2>
<p>Except for passing the result back to the main session, communication between worker sessions are not allowed. This limits how group-by operations can be performed, hence why group-by was done in two stages prior to <code>{disk.frame}</code> v0.3.0. However, R’s meta-programming abilities allow us to rewrite code to perform the two-stage group-bys using one-stage group-by code. For example, consider:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1">df <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="st">  </span><span class="kw">group_by</span>(grp1) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="st">  </span><span class="kw">summarize</span>(<span class="kw">sum</span>(x)) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="st">  </span>collect</a></code></pre></div>
<p>we can use meta-programming to transform that to</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1">df <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="st">  </span><span class="kw">chunk_group_by</span>(grp1) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="st">  </span><span class="kw">chunk_summarize</span>(<span class="dt">__tmp1__=</span> <span class="kw">sum</span>(x)) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="st">  </span><span class="kw">collect</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="st">  </span><span class="kw">group_by</span>(grp1) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="st">  </span><span class="kw">summarize</span>(<span class="dt">x =</span> <span class="kw">sum</span>(__tmp1__))</a></code></pre></div>
<p>Basically, we are “compiling” one-stage group-by code to two-stage group-by code, and then executing it.</p>
<p>For <code>mean</code>, it’s trickier, as one needs to keep track on the numerator and the denominator separately in computing <code>mean(x) = sum(x)/length(x)</code>.</p>
<p>Therefore, <code>{disk.frame}</code> compiles</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1">df <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="st">  </span><span class="kw">group_by</span>(grp1) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="st">  </span><span class="kw">summarize</span>(<span class="dt">meanx =</span> <span class="kw">mean</span>(x)) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="st">  </span>collect</a></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1">df <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="st">  </span><span class="kw">chunk_group_by</span>(grp1) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="st">  </span><span class="kw">chunk_summarize</span>(<span class="dt">__tmp1__ =</span> <span class="kw">list</span>(<span class="kw">mean_df.chunk_agg.disk.frame</span>(x))) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="st">  </span>collect <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="st">  </span><span class="kw">group_by</span>(grp1) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="st">  </span><span class="kw">chunk_summarize</span>(<span class="dt">meanx =</span> <span class="kw">mean_df.chunk_agg.disk.frame</span>(__tmp1__))</a></code></pre></div>
<p>where <code>mean_df.chunk_agg.disk.frame</code> defines what needs to be done to each chunk, as you can see, the return value is a vector where the elements are named <code>sumx</code> and <code>lengthx</code>. Also note because the return value is not a scalar, we need to write it in a <code>list</code> (line 3).</p>
<p>Here is an example implementation of <code>mean.chunk_agg.disk.frame</code></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1">mean_df.chunk_agg.disk.frame &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>, ...) {</a>
<a class="sourceLine" id="cb5-2" title="2">  sumx =<span class="st"> </span><span class="kw">sum</span>(x, <span class="dt">na.rm =</span> na.rm)</a>
<a class="sourceLine" id="cb5-3" title="3">  lengthx =<span class="st"> </span><span class="kw">length</span>(x) <span class="op">-</span><span class="st"> </span><span class="kw">ifelse</span>(na.rm, <span class="kw">sum</span>(<span class="kw">is.na</span>(x)), <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="kw">c</span>(<span class="dt">sumx =</span> sumx, <span class="dt">lengthx =</span> lengthx)</a>
<a class="sourceLine" id="cb5-5" title="5">}</a></code></pre></div>
<p>The <code>mean_df.collected_agg.disk.frame</code> receives a list of outputs from <code>mean_df.chunk_agg.disk.frame</code>. Recall that <code>mean.chunk_agg.disk.frame</code> returns a vector for each chunk, so the input to <code>mean_df.collected_agg.disk.frame</code> is a <em>list of vectors</em></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1">mean_df.collected_agg.disk.frame &lt;-<span class="st"> </span><span class="cf">function</span>(listx) {</a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="kw">sum</span>(<span class="kw">sapply</span>(listx, <span class="cf">function</span>(x) x[<span class="st">&quot;sumx&quot;</span>]))<span class="op">/</span><span class="kw">sum</span>(<span class="kw">sapply</span>(listx, <span class="cf">function</span>(x) x[<span class="st">&quot;lengthx&quot;</span>]))</a>
<a class="sourceLine" id="cb6-3" title="3">}</a></code></pre></div>
</div>
<div id="how-to-define-custom-one-stage-group-by-functions" class="section level2">
<h2>How to define custom one-stage group-by functions</h2>
<p>Now that we have seen two examples, namely <code>sum</code> and <code>mean</code>, we are ready to summarize how group-by functions are implemented.</p>
<p>Given the below</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1">df <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="st">  </span><span class="kw">group_by</span>(grp1) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="st">  </span><span class="kw">summarize</span>(<span class="dt">namex =</span> <span class="kw">fn</span>(x)) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="st">  </span>collect</a></code></pre></div>
<p><code>{disk.frame}</code> compiles it to</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" title="1">df <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="st">  </span><span class="kw">chunk_group_by</span>(grp1) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="st">  </span><span class="kw">chunk_summarize</span>(<span class="dt">__tmp1__ =</span> <span class="kw">list</span>(<span class="kw">fn_df.chunk_agg.disk.frame</span>(x))) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="st">  </span>collect <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="st">  </span><span class="kw">group_by</span>(grp1) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="st">  </span><span class="kw">chunk_summarize</span>(<span class="dt">namex =</span> <span class="kw">fn_df.collected_agg.disk.frame</span>(__tmp1__))</a></code></pre></div>
<p>Based on the above information, to make <code>fn</code> a one-stage group-by function, the user has to</p>
<ol style="list-style-type: decimal">
<li>Define <code>fn_df.chunk_agg.disk.frame</code> which is a function to be applied to each chunk</li>
<li>Define <code>fn_df.collected_agg.disk.frame</code> which is a function to be applied to <em>a <code>list</code> containing the returns from <code>fn.chunk_agg.disk.frame</code> applied to each chunk</em></li>
</ol>
<p><strong>Example of implementing <code>sum</code></strong>:</p>
<ol style="list-style-type: decimal">
<li>Define <code>sum_df.chunk_agg.disk.frame</code></li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" title="1">sum_df.chunk_agg.disk.frame &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>) {</a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="kw">sum</span>(x, <span class="dt">na.rm=</span>na.rm)</a>
<a class="sourceLine" id="cb9-3" title="3">}</a></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Define <code>sum_df.collected_agg.disk.frame</code>, which needs to accept a list of <code>sum(x, na.rm)</code>, but <code>sum(x, na.rm)</code> is just a numeric, so</li>
</ol>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" title="1">sum_df.collected_agg.disk.frame &lt;-<span class="st"> </span><span class="cf">function</span>(list_sum) {</a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="kw">sum</span>(<span class="kw">unlist</span>(list_sum))</a>
<a class="sourceLine" id="cb10-3" title="3">}</a></code></pre></div>
<p><strong>Example of implementing <code>n_distinct</code></strong>:</p>
<p>The <code>dplyr::n_distinct</code> function counts the number of distint values from a vector <code>x</code></p>
<ol style="list-style-type: decimal">
<li>Define <code>n_distinct_df.chunk_agg.disk.frame</code>, to return a list of unique values. Because the same value can appear in multiple chunks, to ensure that we don’t double count, we simply return all the unique values from each chunk which is then de-duplicated in the next phase</li>
</ol>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" title="1">n_distinct_df.chunk_agg.disk.frame &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>) {</a>
<a class="sourceLine" id="cb11-2" title="2">  <span class="cf">if</span>(na.rm) {</a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="kw">setdiff</span>(<span class="kw">unique</span>(x), <span class="ot">NA</span>)</a>
<a class="sourceLine" id="cb11-4" title="4">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="kw">unique</span>(x)</a>
<a class="sourceLine" id="cb11-6" title="6">  }</a>
<a class="sourceLine" id="cb11-7" title="7">}</a></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Define <code>n_distinct_df.collected_agg.disk.frame</code>, which de-duplicates the unique values</li>
</ol>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" title="1">n_distinct_df.collected_agg.disk.frame &lt;-<span class="st"> </span><span class="cf">function</span>(list_of_chunkwise_uniques) {</a>
<a class="sourceLine" id="cb12-2" title="2">  dplyr<span class="op">::</span><span class="kw">n_distinct</span>(<span class="kw">unlist</span>(list_of_chunkwise_uniques))</a>
<a class="sourceLine" id="cb12-3" title="3">}</a></code></pre></div>
</div>
<div id="limitations" class="section level2">
<h2>Limitations</h2>
<p>We have seen that <code>{disk.frame}</code> performs operations in two phases</p>
<ol style="list-style-type: decimal">
<li>apply the same function to each chunk</li>
<li>row-bind the results</li>
</ol>
<p>and there are no communication between the sessions that applies the functions at chunk level.</p>
<p>Hence, it is generally difficult to compute rank based summarizations like <code>median</code> exactly. Hence most rank based calculations are estimates only. This is also true of distributed data system like Spark whose median function is also estimates only.</p>
<p>Another limitation for now is that summarization that is more complex then <code>f(x)</code> is not supported. E.g. <code>sum(x) + 1</code>, <code>sum(x + mean(x))</code>, <code>sum(x) + mean(x)</code>, and <code>fn(sum(x))</code> are not yet supported as arguments in the <code>summarize</code> function.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
